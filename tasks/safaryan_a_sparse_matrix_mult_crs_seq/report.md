Умножение разреженных матриц. Элементы типа double. Формат хранения матрицы – столбцовый (CCS).
Студент: Сафарян Григор Ваагнович
Группа: 3823Б1ПР5
Технологии: SEQ
Вариант: 5


# Отчет по лабораторной работе  
## Тема: Умножение разреженных матриц в формате CRS (элементы типа double)

---

## 1. Постановка задачи

В рамках лабораторной работы требовалось реализовать алгоритм умножения разреженных матриц,
 элементы которых имеют тип `double`.  

Матрицы должны храниться в строковом формате — **CRS (Compressed Row Storage)**.  

Необходимо было:

- Реализовать последовательную версию (SEQ)
- Обеспечить корректную валидацию входных данных
- Реализовать функциональные тесты
- Убедиться в корректности работы алгоритма
- Интегрировать решение в инфраструктуру проекта

---

## 2. Формат хранения матрицы (CRS)

В работе использовалась структура:

```cpp
struct CRSMatrix {
  std::vector<double> values;         
  std::vector<size_t> col_indices;    
  std::vector<size_t> row_ptr;        
  size_t rows = 0;
  size_t cols = 0;
  size_t nnz = 0;
};
```

## Структура CRS:

- values — массив ненулевых элементов
- col_indices — номера столбцов для каждого элемента
- row_ptr — массив размера rows + 1,

где:

- row_ptr[i] — индекс начала строки i
- row_ptr[i+1] — индекс конца строки i
- nnz — количество ненулевых элементов

CRS позволяет эффективно хранить разреженные матрицы и выполнять операции построчно.

3. **Условие корректности умножения**

Для умножения матриц A и B необходимо:

- A.cols == B.rows
- Результирующая матрица C будет иметь размер:
- C.rows = A.rows
- C.cols = B.cols

4. **Алгоритм умножения**

Основная идея

- Для каждой строки i матрицы A:
- Берём все ненулевые элементы A(i, k)
- Для каждого такого элемента:
- Проходим по строке k матрицы B

Выполняем накопление:

C(i, j) += A(i, k) * B(k, j)

Используем временный аккумулятор accum для хранения значений строки результата

Сохраняем только ненулевые элементы в CRS

### Псевдокод

```text
для i = 0 .. A.rows-1
    для каждого (i, k) из A
        для каждого (k, j) из B
            accum[j] += A(i,k) * B(k,j)

    сохранить ненулевые accum[j] в C
    очистить accum
```

5. **Реализация ключевого фрагмента**

```text
for (size_t i = 0; i < a.rows; ++i) {
  c.row_ptr[i] = c.values.size();

  for (size_t a_idx = a.row_ptr[i]; a_idx < a.row_ptr[i + 1]; ++a_idx) {
    const size_t k = a.col_indices[a_idx];
    const double a_val = a.values[a_idx];

    for (size_t b_idx = b.row_ptr[k]; b_idx < b.row_ptr[k + 1]; ++b_idx) {
      const size_t j = b.col_indices[b_idx];
      const double b_val = b.values[b_idx];

      accum[j] += a_val * b_val;
    }
  }

  for (size_t j = 0; j < b.cols; ++j) {
    if (std::abs(accum[j]) > 1e-12) {
      c.col_indices.push_back(j);
      c.values.push_back(accum[j]);
      accum[j] = 0.0;
    }
  }
}
```

6. **Валидация входных данных**

Проверяется:
Размерность матриц
Корректность row_ptr
Соответствие nnz
Диапазон индексов столбцов

Пример:
if (m.row_ptr.size() != m.rows + 1) return false;
if (m.row_ptr[m.rows] != m.nnz) return false;
if (m.values.size() != m.col_indices.size()) return false;

7. **Тестирование**

Были реализованы функциональные тесты:

- Малый фиксированный пример
Проверка на заранее известном результате.
- Случайный тест
Генерация плотных матриц
Преобразование в CRS
Сравнение результата с обычным плотным умножением
- Проверка Validation
Тест на несовместимые размеры.

8. **Сложность алгоритма**

Пусть:
nnz(A) — количество ненулевых элементов в A
nnz(B) — количество ненулевых элементов в B

В худшем случае:
O(nnz(A) * среднее число элементов в строке B)
Алгоритм эффективен для разреженных матриц.

9. **Возникшие проблемы**

Проблема линковки (duplicate symbol)
- Возникла ошибка:
duplicate symbol ...
Причина:
Использование одинаковых namespace и имён тестов из example_threads
Линковщик обнаруживал дублирование классов gtest
- Решение:
Создан уникальный namespace:
safaryan_a_sparse_matrix_mult_crs_seq
Переименованы тестовые классы
Удалено использование example_threads

10. **Результаты**

- Реализовано умножение CRS × CRS
- Реализована корректная валидация
- Написаны функциональные тесты
- Алгоритм успешно проходит проверки
- Проект корректно компилируется без конфликтов

11. **Вывод**

В ходе выполнения работы был реализован алгоритм умножения разреженных матриц в формате CRS.
Были изучены:
- особенности хранения разреженных структур
- эффективное накопление результата
- проверка корректности входных данных
- организация тестирования в инфраструктуре проекта
- Получен практический опыт работы с:
форматами хранения разреженных матриц
gtest
структурой многофайлового C++ проекта
устранением ошибок линковки